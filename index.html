<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
    connect-src 'self' https://api.theporndb.net https://cdnjs.cloudflare.com ws://127.0.0.1:3001;
    img-src * data: https:;
    media-src *;
  ">
  <title>Home</title>
  <!-- Flowbite CSS CDN -->
   <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.5.2/flowbite.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css">
</head>
<body class="bg-gray-900">
  <!-- Exact "Navbar with search" from Flowbite docs, with green colors and custom links -->
  <nav class="bg-white border-gray-200 dark:bg-gray-900">
    <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
      <a href="index.html" class="flex items-center space-x-3 rtl:space-x-reverse">
        <img src="https://flowbite.com/docs/images/logo.svg" class="h-8 w-auto" alt="VideoHub Logo" />
        <span class="self-center text-2xl font-semibold whitespace-nowrap dark:text-white">VideoHub</span>
      </a>
      <div class="flex md:order-2 space-x-3 rtl:space-x-reverse">
        <button type="button" data-collapse-toggle="navbar-search" aria-controls="navbar-search" aria-expanded="false" class="md:hidden text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-green-300 rounded-lg text-sm p-2.5 me-2">
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
          </svg>
          <span class="sr-only">Search</span>
        </button>
        <div class="relative hidden md:block">
          <div class="absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none">
            <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
            </svg>
            <span class="sr-only">Search icon</span>
          </div>
          <input type="text" id="search-navbar" class="block w-full p-2 ps-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-green-500 focus:border-green-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-green-500 dark:focus:border-green-500" placeholder="Search videos, performers, studios..." oninput="handleSearch()" onkeydown="handleEnter(event)">
          <!-- Suggestions container positioned relative to search input -->
          <div id="search-suggestions" class="search-suggestions hidden"></div>
        </div>
        <button data-collapse-toggle="navbar-search" type="button" class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-search" aria-expanded="false">
          <span class="sr-only">Open main menu</span>
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
          </svg>
        </button>
      </div>
      <div class="items-center justify-between hidden w-full md:flex md:w-auto md:order-1" id="navbar-search">
        <div class="relative mt-3 md:hidden">
          <div class="absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none">
            <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
            </svg>
          </div>
          <input type="text" id="search-navbar-mobile" class="block w-full p-2 ps-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-green-500 focus:border-green-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-green-500 dark:focus:border-green-500" placeholder="Search videos, performers, studios..." oninput="handleSearch()" onkeydown="handleEnter(event)">
          <div id="search-suggestions-mobile" class="search-suggestions hidden"></div>
        </div>
        <ul class="flex flex-col p-4 md:p-0 mt-4 font-medium border border-gray-100 rounded-lg bg-gray-50 md:space-x-8 rtl:space-x-reverse md:flex-row md:mt-0 md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a href="index.html" class="block py-2 px-3 text-white bg-green-700 rounded-md md:bg-transparent md:text-green-700 md:p-0 md:dark:text-green-500" aria-current="page">Home</a>
          </li>
          <li>
            <a href="studio.html" class="block py-2 px-3 text-gray-900 rounded-md hover:bg-gray-100 md:hover:bg-transparent md:hover:text-green-700 md:p-0 md:dark:hover:text-green-500 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700">Studio</a>
          </li>
          <li>
            <a href="performers.html" class="block py-2 px-3 text-gray-900 rounded-md hover:bg-gray-100 md:hover:bg-transparent md:hover:text-green-700 md:p-0 md:dark:hover:text-green-500 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700">Performers</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="pagination" id="pagination-top"></div>

  <div class="video-list-container">
    <div class="video-list" id="video-list"></div>
  </div>

  <div class="pagination" id="pagination-bottom"></div>

  <!-- Flowbite JavaScript CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.5.2/flowbite.min.js"></script>
  <script>
    const API_TOKEN = 'Bearer Aor5JIDSkxOhmXmNAOYP5Gnr73u7u3UPJZYaevBT2558d467';
    const itemsPerPage = 10;
    const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours
    const urlParams = new URLSearchParams(window.location.search);
    let currentPage = parseInt(urlParams.get('page')) || 1;
    let allVideos = [];
    let videoById = new Map(); // Quick lookup for caching/search
    let db = null;
    let searchTimeout;

    const searchInput = document.getElementById('search-navbar');
    const searchInputMobile = document.getElementById('search-navbar-mobile');
    const searchSuggestions = document.getElementById('search-suggestions');
    const searchSuggestionsMobile = document.getElementById('search-suggestions-mobile');
    const videoListContainer = document.getElementById('video-list');
    const paginationTop = document.getElementById('pagination-top');
    const paginationBottom = document.getElementById('pagination-bottom');

    // IndexedDB Setup
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('VideoHubCache', 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('videos')) {
            const store = db.createObjectStore('videos', { keyPath: 'id' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    // Cache functions
    async function getFromCache(id) {
      if (!db) return null;
      return new Promise((resolve) => {
        const tx = db.transaction('videos', 'readonly');
        const store = tx.objectStore('videos');
        const req = store.get(id);
        req.onsuccess = () => {
          const data = req.result;
          if (data && Date.now() - data.timestamp < CACHE_TTL) {
            resolve(data);
          } else {
            if (data) {
              // Delete stale
              const deleteTx = db.transaction('videos', 'readwrite');
              deleteTx.objectStore('videos').delete(id);
            }
            resolve(null);
          }
        };
        req.onerror = () => resolve(null);
      });
    }

    async function putToCache(id, data) {
      if (!db) return;
      const tx = db.transaction('videos', 'readwrite');
      const store = tx.objectStore('videos');
      store.put({ ...data, id, timestamp: Date.now() });
    }

    // Enhance video with API data
    async function enhanceVideo(video) {
      const cache = await getFromCache(video.id);
      if (cache) {
        applyData(video, cache);
        return;
      }

      // Fetch scene
      let sceneData = null;
      try {
        const sceneRes = await fetch(`https://api.theporndb.net/scenes/${video.id}?add_to_collection=true`, {
          headers: { 'accept': 'application/json', 'Authorization': API_TOKEN }
        });
        if (sceneRes.ok) {
          const sceneJson = await sceneRes.json();
          sceneData = sceneJson.data || {};
        }
      } catch (err) {
        console.error(`Error fetching scene ${video.id}:`, err);
      }

      // Fetch performer if needed
      let performerData = null;
      if (video.performers.length > 0) {
        try {
          const perfRes = await fetch(`https://api.theporndb.net/performers/${video.performers[0]}`, {
            headers: { 'accept': 'application/json', 'Authorization': API_TOKEN }
          });
          if (perfRes.ok) {
            const perfJson = await perfRes.json();
            performerData = perfJson.data;
          }
        } catch (err) {
          console.error(`Error fetching performer for ${video.id}:`, err);
        }
      }

      applyData(video, { scene: sceneData, performer: performerData });
      await putToCache(video.id, { scene: sceneData, performer: performerData });
    }

    function applyData(video, data) {
      const sceneData = data.scene;
      if (sceneData) {
        if (!video.thumbnail || video.thumbnail === 'https://via.placeholder.com/300x200?text=No+Image') {
          video.thumbnail = sceneData.background?.full || 'https://via.placeholder.com/300x200?text=No+Image';
        }
        video.description = video.description || sceneData.description || 'No description available';
        video.title = video.title && video.title !== 'Untitled Video' ? video.title : (sceneData.title || 'Untitled Video');
        video.type = video.type && video.type !== 'Unknown' ? video.type : (sceneData.type || 'Unknown');
        video.rating = video.rating || sceneData.rating || 0;
        video.url = video.url && video.url !== '#' ? video.url : (sceneData.url || '#');
        video.trailer = video.trailer || sceneData.trailer || '';
        video.site_id = video.site_id || sceneData.site?.id || 0;
        video.site = {
          id: video.site.id || sceneData.site?.id || 0,
          name: video.site.name && video.site.name !== 'Unknown Studio' ? video.site.name : (sceneData.site?.name || 'Unknown Studio'),
          short_name: video.site.short_name && video.site.short_name !== 'Unknown' ? video.site.short_name : (sceneData.site?.short_name || 'Unknown'),
          rating: video.site.rating || sceneData.site?.rating || 0,
          logo: video.site.logo || sceneData.site?.logo || '',
          parent: video.site.parent && video.site.parent.name !== 'Unknown' ? video.site.parent : (sceneData.site?.parent || { id: 0, name: 'Unknown', short_name: 'Unknown' })
        };
      }

      if (data.performer) {
        video.actressName = video.actressName || data.performer.name || 'Unknown';
      } else {
        video.actressName = video.actressName || 'Unknown';
      }

      if (!video.thumbnail) {
        video.thumbnail = 'https://via.placeholder.com/300x200?text=No+Image';
      }
      if (!video.description) {
        video.description = 'Error fetching description';
      }
    }

    // Sync mobile and desktop search inputs
    function syncSearchInputs(source) {
      if (source === searchInput && searchInputMobile) {
        searchInputMobile.value = source.value;
      } else if (source === searchInputMobile && searchInput) {
        searchInput.value = source.value;
      }
    }

    // Debounced search
    function debouncedSearch() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(handleSearch, 300);
    }

    // Fetch video data from video.json
    async function loadVideos() {
      try {
        const response = await fetch('video.json');
        const jsonData = await response.json();
        allVideos = jsonData.videos.map(video => {
          const v = {
            video_Id: video.video_Id,
            id: video.data._id,
            title: video.data.title || 'Untitled Video',
            type: video.data.type || 'Unknown',
            rating: video.data.rating || 0,
            site_id: video.data.site_id || video.data.site?.id || 0,
            url: video.data.url || '#',
            trailer: video.data.trailer || '',
            thumbnail: video.data.background?.full || null,
            site: {
              id: video.data.site?.id || 0,
              name: video.data.site?.name || 'Unknown Studio',
              short_name: video.data.site?.short_name || 'Unknown',
              rating: video.data.site?.rating || 0,
              logo: video.data.site?.logo || '',
              parent: video.data.site?.parent || { id: 0, name: 'Unknown', short_name: 'Unknown' }
            },
            performers: video.data.performers?.map(p => p._id) || [],
            actressName: ''
          };
          videoById.set(v.id, v);
          return v;
        });

        // Reverse the array to show last JSON entry first
        allVideos.reverse();

        await initDB();
        renderPagination();
        await renderVideos(); // This will trigger enhancement for current page only
      } catch (error) {
        console.error('Error fetching video.json:', error);
        videoListContainer.innerHTML = '<p>Error loading videos.</p>';
      }
    }

    async function renderVideos() {
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const videosToShow = allVideos.slice(startIndex, endIndex);

      if (videosToShow.length === 0) {
        videoListContainer.innerHTML = '<p>No videos found.</p>';
        return;
      }

      // Render placeholders first for instant UI
      renderVideoItems(videosToShow, true);

      // Enhance in parallel (paginated: only current page)
      await Promise.all(videosToShow.map(video => enhanceVideo(video)));

      // Re-render with full data
      renderVideoItems(videosToShow, false);
    }

    function renderVideoItems(videos, placeholder = false) {
      videoListContainer.innerHTML = '';
      videos.forEach(video => {
        const videoItem = document.createElement('div');
        videoItem.classList.add('video-item');
        const actress = placeholder ? 'Loading...' : (video.actressName || 'Unknown');
        const title = placeholder ? `${video.title.substring(0, 20)}...` : video.title;
        const thumb = placeholder ? 'https://via.placeholder.com/300x200?text=Loading' : video.thumbnail;
        videoItem.innerHTML = `
          <a href="video.html?id=${video.id}">
            <img src="${thumb}" alt="${title}" onerror="this.src='https://via.placeholder.com/300x200?text=Image+Failed'">
            <h3>${title}</h3>
            <div class="actress-box">${actress}</div>
          </a>`;
        videoListContainer.appendChild(videoItem);
      });
    }

    function renderPagination() {
      const totalPages = Math.ceil(allVideos.length / itemsPerPage);
      [paginationTop, paginationBottom].forEach(pag => {
        pag.innerHTML = '';
        const maxPagesToShow = 7;
        let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
        let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

        if (endPage - startPage < maxPagesToShow - 1) {
          startPage = Math.max(1, endPage - maxPagesToShow + 1);
        }

        const createButton = (page, label = page, isDisabled = false, isActive = false) => {
          const btn = document.createElement('a');
          btn.innerText = label;
          if (isDisabled) {
            btn.classList.add('disabled');
          } else {
            btn.href = `?page=${page}`;
            btn.addEventListener('click', (e) => {
              e.preventDefault();
              currentPage = page;
              history.pushState({}, '', `?page=${page}`);
              renderVideos();
              renderPagination();
            });
          }
          if (isActive) btn.classList.add('active');
          return btn;
        };

        if (currentPage > 1) {
          pag.appendChild(createButton(currentPage - 1, 'Prev'));
        }

        for (let i = startPage; i <= endPage; i++) {
          pag.appendChild(createButton(i, i, false, i === currentPage));
        }

        if (currentPage < totalPages) {
          pag.appendChild(createButton(currentPage + 1, 'Next'));
        }
      });
    }

    async function handleSearch() {
      const query = (searchInput?.value || searchInputMobile?.value || '').trim();
      if (!query) {
        [searchSuggestions, searchSuggestionsMobile].forEach(s => s.classList.add('hidden'));
        return;
      }

      // Local filter using allVideos (enhanced data)
      const localResults = allVideos.filter(video =>
        video.title.toLowerCase().includes(query.toLowerCase()) ||
        video.site.name.toLowerCase().includes(query.toLowerCase()) ||
        (video.site.parent?.name || '').toLowerCase().includes(query.toLowerCase()) ||
        video.actressName.toLowerCase().includes(query.toLowerCase())
      ).slice(0, 5);

      // API search for additional results (limited, as before)
      try {
        const [scenesResponse, performersResponse, sitesResponse] = await Promise.all([
          fetch(`https://api.theporndb.net/scenes?query=${encodeURIComponent(query)}`, {
            headers: { 'accept': 'application/json', 'Authorization': API_TOKEN }
          }),
          fetch(`https://api.theporndb.net/performers?query=${encodeURIComponent(query)}`, {
            headers: { 'accept': 'application/json', 'Authorization': API_TOKEN }
          }),
          fetch(`https://api.theporndb.net/sites?query=${encodeURIComponent(query)}`, {
            headers: { 'accept': 'application/json', 'Authorization': API_TOKEN }
          })
        ]);

        const [scenesData, performersData, sitesData] = await Promise.all([
          scenesResponse.json(),
          performersResponse.json(),
          sitesResponse.json()
        ]);

        // Cross-check and combine API results
        const apiResults = [
          ...(scenesData.data || []).filter(scene => videoById.has(scene._id)).map(scene => ({
            id: scene._id,
            title: scene.title,
            thumbnail: scene.background?.full || 'https://via.placeholder.com/300x200?text=No+Image'
          })),
          ...(performersData.data || []).flatMap(performer => {
            const matchingVideos = allVideos.filter(v => v.performers.includes(performer._id));
            return matchingVideos.slice(0, 2).map(v => ({ id: v.id, title: v.title, thumbnail: v.thumbnail }));
          }),
          ...(sitesData.data || []).flatMap(site => {
            const matchingVideos = allVideos.filter(v => v.site_id === site._id || v.site.id === site._id);
            return matchingVideos.slice(0, 2).map(v => ({ id: v.id, title: v.title, thumbnail: v.thumbnail }));
          })
        ].slice(0, 5);

        const combinedIds = [...new Set([...localResults.map(r => r.id), ...apiResults.map(r => r.id)])].slice(0, 5);
        const combinedResults = combinedIds.map(id => videoById.get(id));

        // Render suggestions
        const renderSuggestions = (container, results) => {
          container.innerHTML = results.length ? results.map(video => `
            <div class="flex items-center p-2 cursor-pointer hover:bg-gray-700" onclick="window.location.href='video.html?id=${video.id}'">
              <img src="${video.thumbnail}" alt="${video.title}" class="w-10 h-10 rounded mr-2" onerror="this.src='https://via.placeholder.com/300x200?text=Image+Failed'">
              <span class="text-white text-sm">${video.title}</span>
            </div>
          `).join('') : '<div class="p-2 text-white text-sm">No results found</div>';
          container.classList.toggle('hidden', !results.length);
        };

        renderSuggestions(searchSuggestions, combinedResults);
        renderSuggestions(searchSuggestionsMobile, combinedResults);
      } catch (error) {
        console.error('Error fetching search results:', error);
        [searchSuggestions, searchSuggestionsMobile].forEach(container => {
          container.innerHTML = '<div class="p-2 text-white text-sm">Error fetching results</div>';
          container.classList.remove('hidden');
        });
      }
    }

    function handleEnter(event) {
      if (event.key === "Enter") {
        const query = (searchInput?.value || searchInputMobile?.value || '').trim();
        if (query) {
          window.location.href = `search.html?query=${encodeURIComponent(query)}`;
        }
        [searchSuggestions, searchSuggestionsMobile].forEach(s => s.classList.add('hidden'));
      }
    }

    // Init on load
    loadVideos();

    // Event listeners
    searchInput?.addEventListener('input', () => { debouncedSearch(); syncSearchInputs(searchInput); });
    searchInputMobile?.addEventListener('input', () => { debouncedSearch(); syncSearchInputs(searchInputMobile); });
  </script>
</body>
</html>
