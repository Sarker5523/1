<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="List of female performers on VideoHub, showcasing all available performers.">
  <meta name="robots" content="index, follow">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com;
    connect-src 'self' https://api.theporndb.net https://cdnjs.cloudflare.com ws://127.0.0.1:3001;
    img-src * data: https:;
    media-src *;
    font-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com;
  ">
  <title>Performers - VideoHub</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.5.2/flowbite.min.css" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body class="bg-gray-900">

  <!-- Navbar -->
  <nav class="bg-white border-gray-200 dark:bg-gray-900">
    <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
      <a href="index.html" class="flex items-center space-x-3 rtl:space-x-reverse">
        <img src="https://flowbite.com/docs/images/logo.svg" class="h-8 w-auto" alt="VideoHub Logo" />
        <span class="self-center text-2xl font-semibold whitespace-nowrap dark:text-white">VideoHub</span>
      </a>
      <div class="flex md:order-2 space-x-3 rtl:space-x-reverse">
        <button type="button" data-collapse-toggle="navbar-search" aria-controls="navbar-search" aria-expanded="false" class="md:hidden text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-green-300 rounded-lg text-sm p-2.5 me-2">
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
          </svg>
          <span class="sr-only">Search</span>
        </button>
        <div class="relative hidden md:block">
          <div class="absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none">
            <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
            </svg>
          </div>
          <input type="text" id="search-navbar" class="block w-full p-2 ps-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-green-500 focus:border-green-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-green-500 dark:focus:border-green-500" placeholder="Search videos, performers, studios..." oninput="handleSearch()" onkeydown="handleEnter(event)">
          <div id="search-suggestions" class="search-suggestions hidden"></div>
        </div>
        <button data-collapse-toggle="navbar-search" type="button" class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-search" aria-expanded="false">
          <span class="sr-only">Open main menu</span>
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
          </svg>
        </button>
      </div>
      <div class="items-center justify-between hidden w-full md:flex md:w-auto md:order-1" id="navbar-search">
        <div class="relative mt-3 md:hidden">
          <div class="absolute inset-y-0 start-0 flex items-center ps-3 pointer-events-none">
            <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
            </svg>
          </div>
          <input type="text" id="search-navbar-mobile" class="block w-full p-2 ps-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-green-500 focus:border-green-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-green-500 dark:focus:border-green-500" placeholder="Search videos, performers, studios..." oninput="handleSearch()" onkeydown="handleEnter(event)">
          <div id="search-suggestions-mobile" class="search-suggestions hidden"></div>
        </div>
        <ul class="flex flex-col p-4 md:p-0 mt-4 font-medium border border-gray-100 rounded-lg bg-gray-50 md:space-x-8 rtl:space-x-reverse md:flex-row md:mt-0 md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li><a href="index.html" class="block py-2 px-3 text-gray-900 rounded-md hover:bg-gray-100 md:hover:bg-transparent md:hover:text-green-700 md:p-0 md:dark:hover:text-green-500 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700">Home</a></li>
          <li><a href="studio.html" class="block py-2 px-3 text-gray-900 rounded-md hover:bg-gray-100 md:hover:bg-transparent md:hover:text-green-700 md:p-0 md:dark:hover:text-green-500 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700">Studio</a></li>
          <li><a href="performer.html" class="block py-2 px-3 text-white bg-green-700 rounded-md md:bg-transparent md:text-green-700 md:p-0 md:dark:text-green-500" aria-current="page">Performers</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="pagination" id="pagination-top"></div>
  <div class="video-list-container">
    <div class="video-list" id="performer-list"></div>
  </div>
  <div class="pagination" id="pagination-bottom"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.5.2/flowbite.min.js"></script>
  <script>
    const API_TOKEN = 'Bearer Aor5JIDSkxOhmXmNAOYP5Gnr73u7u3UPJZYaevBT2558d467';
    const itemsPerPage = 10;
    const CACHE_TTL = 24 * 60 * 60 * 1000;
    const MAX_RETRIES = 5;
    const RETRY_DELAY_BASE = 250;
    const urlParams = new URLSearchParams(window.location.search);
    let currentPage = parseInt(urlParams.get('page')) || 1;
    let allPerformers = [];
    let performerByName = new Map();
    let db = null;
    let searchTimeout;
    const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    const searchInput = document.getElementById('search-navbar');
    const searchInputMobile = document.getElementById('search-navbar-mobile');
    const searchSuggestions = document.getElementById('search-suggestions');
    const searchSuggestionsMobile = document.getElementById('search-suggestions-mobile');
    const performerListContainer = document.getElementById('performer-list');
    const paginationTop = document.getElementById('pagination-top');
    const paginationBottom = document.getElementById('pagination-bottom');

    /* --------------------------------------------------------------
       IndexedDB
    -------------------------------------------------------------- */
    async function initDBWithRetry(maxAttempts = 5) {
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          return await new Promise((resolve, reject) => {
            const req = indexedDB.open('VideoHubCache', 1);
            req.onerror = () => reject(req.error);
            req.onsuccess = () => { db = req.result; resolve(db); };
            req.onupgradeneeded = e => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains('videos')) {
                db.createObjectStore('videos', { keyPath: 'id' }).createIndex('timestamp', 'timestamp');
              }
              if (!db.objectStoreNames.contains('performers')) {
                db.createObjectStore('performers', { keyPath: 'id' }).createIndex('timestamp', 'timestamp');
              }
            };
          });
        } catch (err) {
          console.warn(`DB init attempt ${attempt} failed:`, err);
          if (attempt === maxAttempts) throw err;
          await new Promise(r => setTimeout(r, RETRY_DELAY_BASE * attempt));
        }
      }
    }

    async function getFromCache(id, storeName = 'performers') {
      if (!db) return null;
      return new Promise(resolve => {
        const tx = db.transaction(storeName, 'readonly');
        const req = tx.objectStore(storeName).get(id);
        req.onsuccess = () => {
          const d = req.result;
          if (d && Date.now() - d.timestamp < CACHE_TTL) resolve(d.payload);
          else {
            if (d) db.transaction(storeName, 'readwrite').objectStore(storeName).delete(id);
            resolve(null);
          }
        };
        req.onerror = () => resolve(null);
      });
    }

    async function putToCache(id, payload, storeName = 'performers') {
      if (!db) return;
      db.transaction(storeName, 'readwrite').objectStore(storeName)
        .put({ id, payload, timestamp: Date.now() });
    }

    /* --------------------------------------------------------------
       Safari-safe fetch with manual timeout
    -------------------------------------------------------------- */
    async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timeoutId);
        return res;
      } catch (err) {
        clearTimeout(timeoutId);
        throw err;
      }
    }

    async function fetchSceneWithRetry(id, attempt = 1) {
      const timeoutMs = isIOSSafari ? 20000 : 12000;
      try {
        const res = await fetchWithTimeout(`https://api.theporndb.net/scenes/${id}?add_to_collection=true`, {
          headers: { 'accept': 'application/json', 'Authorization': API_TOKEN },
          cache: 'no-store'
        }, timeoutMs);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (err) {
        console.warn(`[Scene ${id} retry ${attempt}]`, err.name, err.message);
        if (attempt >= MAX_RETRIES) return null;
        const delay = RETRY_DELAY_BASE * (2 ** (attempt - 1)) + Math.random() * 200;
        await new Promise(r => setTimeout(r, delay));
        return fetchSceneWithRetry(id, attempt + 1);
      }
    }

    /* --------------------------------------------------------------
       OPTIONAL: Enrich females only (using search endpoint to avoid 404s)
    -------------------------------------------------------------- */
    async function enrichFemalesOnly(femalePerformers) {
      // Skip enrichment to avoid 404s - use scene data only
      // If you want bios, uncomment below (uses search, not direct fetch)
      /*
      const cacheResults = await Promise.all(
        femalePerformers.map(p => getFromCache(`name_${p.name.toLowerCase()}`, 'performers'))
      );

      const toFetch = femalePerformers.filter((_, i) => !cacheResults[i]);

      if (toFetch.length === 0) return;

      // Search for females (safer than direct fetch)
      for (let i = 0; i < toFetch.length; i += 3) {
        const batch = toFetch.slice(i, i + 3);
        const searchPromises = batch.map(p => 
          fetchWithTimeout(`https://api.theporndb.net/performers?query=${encodeURIComponent(p.name)}&gender=female`, {
            headers: { 'accept': 'application/json', 'Authorization': API_TOKEN },
            cache: 'no-store'
          }, 15000).then(res => res.ok ? res.json() : null)
        );
        const results = await Promise.all(searchPromises);

        results.forEach((json, idx) => {
          if (!json?.data?.performers?.[0]) return;
          const performer = json.data.performers[0];
          const payload = { performer };
          applyPerformerData(batch[idx], payload);
          putToCache(`name_${batch[idx].name.toLowerCase()}`, payload, 'performers');
        });
      }
      */
      console.log(`Skipping enrichment for ${femalePerformers.length} females to avoid API 404s`);
    }

    function applyPerformerData(performer, payload) {
      const p = payload.performer;
      performer.name = (p?.name || performer.name || 'Unknown').trim();
      performer.thumbnail = p?.image || p?.images?.[0]?.jpeg?.url || performer.thumbnail || 'https://placehold.co/300x200?text=No+Image';
      performer.bio = p?.bio || 'No bio available';
      performer.gender = (p?.gender || performer.gender || 'female').toLowerCase();
    }

    /* --------------------------------------------------------------
       Load Performers (Females ONLY from start)
    -------------------------------------------------------------- */
    async function loadPerformers() {
      try {
        if (window.location.protocol === 'file:') {
          performerListContainer.innerHTML = '<p class="text-yellow-400 p-4">Warning: Running on file://. Pagination may not work. Use a local server.</p>';
        }

        const cached = localStorage.getItem('female_performers');
        if (cached) {
          allPerformers = JSON.parse(cached);
          if (allPerformers.length) {
            performerByName = new Map(allPerformers.map(p => [p.name.toLowerCase(), p]));
            console.log(`Loaded ${allPerformers.length} female performers from cache`);
            renderPagination();
            renderCurrentPage();
            return;
          }
        }

        const res = await fetch('video.json');
        if (!res.ok) throw new Error(`video.json ${res.status}`);
        const json = await res.json();

        const performerSet = new Set();
        const allUniquePerformers = []; // Temp: all genders

        for (const video of json.videos || []) {
          const sceneId = video.data?._id;
          if (!sceneId) continue;

          let sceneData = await getFromCache(sceneId, 'videos');
          if (!sceneData) {
            const sceneJson = await fetchSceneWithRetry(sceneId);
            if (!sceneJson?.data) continue;
            sceneData = {
              id: sceneId,
              performers: sceneJson.data.performers || [],
              thumbnail: sceneJson.data.background?.full || sceneJson.data.poster || 'https://placehold.co/300x200?text=No+Image'
            };
            await putToCache(sceneId, sceneData, 'videos');
          }

          for (const p of sceneData.performers || []) {
            const name = (p.name || p._id || '').trim();
            if (!name) continue;

            const lowerName = name.toLowerCase();
            if (performerSet.has(lowerName)) {
              // Update existing
              const existing = allUniquePerformers.find(per => per.name.toLowerCase() === lowerName);
              if (existing) existing.sceneIds.push(sceneId);
              continue;
            }

            performerSet.add(lowerName);
            allUniquePerformers.push({
              name,
              thumbnail: sceneData.thumbnail,
              bio: '',
              gender: p.gender || 'unknown', // Use gender from scene if available
              sceneIds: [sceneId]
            });
          }
        }

        // FILTER TO FEMALES ONLY (early, before any enrichment)
        const femalePerformers = allUniquePerformers.filter(p => 
          p.gender.toLowerCase() === 'female' || 
          !p.gender || // Assume female if unknown (common for your data)
          p.name.toLowerCase().includes('female') // Fallback check
        );

        console.log(`Found ${allUniquePerformers.length} total unique performers, filtered to ${femalePerformers.length} females`);

        // Optional: Enrich only females (uncomment in applyPerformerData if needed)
        await enrichFemalesOnly(femalePerformers);

        // Sort and cache
        allPerformers = femalePerformers.sort((a, b) => a.name.localeCompare(b.name));
        performerByName = new Map(allPerformers.map(p => [p.name.toLowerCase(), p]));
        localStorage.setItem('female_performers', JSON.stringify(allPerformers));

        renderPagination();
        renderCurrentPage();
      } catch (e) {
        console.error('Failed to load performers:', e);
        performerListContainer.innerHTML = '<p class="text-red-400 p-4">Failed to load performers.</p>';
      }
    }

    /* --------------------------------------------------------------
       Render
    -------------------------------------------------------------- */
    function renderCurrentPage() {
      const start = (currentPage - 1) * itemsPerPage;
      const end = start + itemsPerPage;
      const pagePerformers = allPerformers.slice(start, end);

      if (!pagePerformers.length) {
        performerListContainer.innerHTML = '<p class="text-gray-400 p-4">No female performers found.</p>';
        return;
      }

      renderRealPerformers(pagePerformers);
    }

    function renderRealPerformers(performers) {
      performerListContainer.innerHTML = '';
      performers.forEach(p => {
        const div = document.createElement('div');
        div.className = 'video-item';
        div.innerHTML = `
          <a href="performer.html?name=${encodeURIComponent(p.name)}">
            <img src="${p.thumbnail}" alt="${p.name}" class="w-full h-48 object-cover rounded-t-lg"
                 onerror="this.src='https://placehold.co/300x200?text=No+Image'">
            <h3 class="text-lg font-semibold text-white mt-2 truncate">${p.name}</h3>
          </a>`;
        performerListContainer.appendChild(div);
      });
    }

    /* --------------------------------------------------------------
       Pagination
    -------------------------------------------------------------- */
    function renderPagination() {
      const total = Math.ceil(allPerformers.length / itemsPerPage);
      [paginationTop, paginationBottom].forEach(el => {
        el.innerHTML = '';
        const max = 4;
        let start = Math.max(1, currentPage - Math.floor(max / 2));
        let end = Math.min(total, start + max - 1);
        if (end - start < max - 1) start = Math.max(1, end - max + 1);

        const btn = (page, txt = page, disabled = false, active = false) => {
          const a = document.createElement('a');
          a.innerText = txt;
          a.href = `performer.html?page=${page}`;
          a.className = `px-3 py-2 text-sm font-medium ${active ? 'text-green-500 bg-gray-800' : 'text-gray-300 hover:text-white'} rounded-md`;
          if (active || disabled) a.classList.add('cursor-default');
          else {
            a.onclick = e => {
              e.preventDefault();
              currentPage = page;
              window.history.pushState({}, '', a.href);
              renderPagination();
              renderCurrentPage();
            };
          }
          return a;
        };

        if (currentPage > 1) el.appendChild(btn(currentPage - 1, 'Prev'));
        for (let i = start; i <= end; i++) el.appendChild(btn(i, i, false, i === currentPage));
        if (currentPage < total) el.appendChild(btn(currentPage + 1, 'Next'));
      });
    }

    /* --------------------------------------------------------------
       Search
    -------------------------------------------------------------- */
    function syncSearchInputs(src) {
      if (src === searchInput && searchInputMobile) searchInputMobile.value = src.value;
      if (src === searchInputMobile && searchInput) searchInput.value = src.value;
    }

    function debouncedSearch() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(handleSearch, 300);
    }

    function handleSearch() {
      const q = (searchInput?.value || searchInputMobile?.value || '').trim().toLowerCase();
      if (!q) {
        [searchSuggestions, searchSuggestionsMobile].forEach(s => s.classList.add('hidden'));
        return;
      }

      const results = allPerformers
        .filter(p => p.name.toLowerCase().includes(q))
        .slice(0, 5);

      const render = (container, list) => {
        container.innerHTML = list.length
          ? list.map(p => `
              <div class="flex items-center p-2 cursor-pointer hover:bg-gray-700"
                   onclick="window.location.href='performer.html?name=${encodeURIComponent(p.name)}'">
                <img src="${p.thumbnail}" alt="${p.name}" class="w-10 h-10 rounded mr-2 object-cover"
                     onerror="this.src='https://placehold.co/40x40?text=No'">
                <span class="text-white text-sm">${p.name}</span>
              </div>`).join('')
          : '<div class="p-2 text-white text-sm">No results</div>';
        container.classList.toggle('hidden', list.length === 0);
      };

      render(searchSuggestions, results);
      render(searchSuggestionsMobile, results);
    }

    function handleEnter(e) {
      if (e.key === 'Enter') {
        const q = (searchInput?.value || searchInputMobile?.value || '').trim();
        if (q) window.location.href = `search.html?query=${encodeURIComponent(q)}`;
        [searchSuggestions, searchSuggestionsMobile].forEach(s => s.classList.add('hidden'));
      }
    }

    /* --------------------------------------------------------------
       Init
    -------------------------------------------------------------- */
    async function init() {
      await initDBWithRetry();
      await loadPerformers();

      window.addEventListener('popstate', () => {
        const params = new URLSearchParams(window.location.search);
        const page = parseInt(params.get('page')) || 1;
        if (page !== currentPage) {
          currentPage = page;
          renderPagination();
          renderCurrentPage();
        }
      });
    }

    init();

    searchInput?.addEventListener('input', () => { debouncedSearch(); syncSearchInputs(searchInput); });
    searchInputMobile?.addEventListener('input', () => { debouncedSearch(); syncSearchInputs(searchInputMobile); });
    searchInput?.addEventListener('keydown', handleEnter);
    searchInputMobile?.addEventListener('keydown', handleEnter);
  </script>
</body>
</html>
